import logging
import os
import json
import subprocess
import datetime

from scripts.check_if_executable import check_if_executable
from scripts.copy_pyc_files import copy_pyc_files


def convert_to_serializable(obj):
    if isinstance(obj, bytes):
        return obj.decode("utf-8")
    raise TypeError("Object of type %s is not JSON serializable" %
                    type(obj).__name__)


def extract_and_analyse():
    # Directory where the malicious PE files are located
    files_directory = os.path.join(".", "inputs")
    logs_directory = os.path.join(".", "logs")
    app_extracted_folder = os.path.join(".", "app_extracted")

    # Create the output directory if it doesn't exist
    os.makedirs(files_directory, exist_ok=True)
    os.makedirs(logs_directory, exist_ok=True)

    # Configure logging
    logging.basicConfig(level=logging.INFO)

    # Initialize an empty list to store the logs
    logs = []

    # Iterate over the files in the input directory
    for filename in os.listdir(files_directory):
        # Check if the file is a PE file
        if filename.lower().endswith(".pyc"):
            print("this is a .pyc file.")
            # Perform decompilation for .pyc files

            # Decompilation using python-uncompyle6
            res = subprocess.run(["./pycdc/pycdc", os.path.join(files_directory, filename)],
                                 stdout=subprocess.PIPE, stderr=subprocess.PIPE)

            # Write the decompiled content to a file
            decompiled_content = res.stdout.decode("utf-8")
            decompiled_filename = os.path.splitext(filename)[0] + ".py"
            decompiled_file_path = os.path.join(
                files_directory, decompiled_filename)
            with open(decompiled_file_path, "w") as f:
                f.write(decompiled_content)
            for extracted_filename in os.listdir(files_directory):
                if extracted_filename.lower().endswith(".pyc"):
                    extracted_file_path = os.path.join(
                        decompiled_file_path, extracted_filename)

                    # Decompilation using python-uncompyle6
                    res = subprocess.run(["./pycdc/pycdc", extracted_file_path],
                                         stdout=subprocess.PIPE, stderr=subprocess.PIPE)

                    # Write the decompiled content to a file
                    decompiled_content = res.stdout.decode("utf-8")
                    decompiled_filename = os.path.splitext(
                        extracted_filename)[0] + ".py"
                    decompiled_file_path = os.path.join(
                        files_directory, decompiled_filename)
                    with open(decompiled_file_path, "w") as f:
                        f.write(decompiled_content)

        elif check_if_executable(filename):
            print("this is an executable file.")
            # Construct the output directory path
            extracted_bytecode_directory = os.path.join(
                files_directory, "extracted_bytecode")
            os.makedirs(extracted_bytecode_directory, exist_ok=True)

            # Construct the output file path
            extracted_bytecode_filename = "app_extracted"
            extracted_bytecode_path = os.path.join(
                extracted_bytecode_directory, extracted_bytecode_filename)
            os.makedirs(extracted_bytecode_path, exist_ok=True)

            # Run pyinstxtractor to extract pyc files
            logs.append(subprocess.run(
                ["python3", "./pyinstxtractor/pyinstxtractor.py", os.path.join(files_directory, filename), "-o",
                 extracted_bytecode_path],
                stdout=subprocess.PIPE, stderr=subprocess.PIPE).__dict__)

            # Move the extracted .pyc files to the input folder
            copy_pyc_files(extracted_bytecode_path, files_directory)

            # Perform decompilation for the extracted .pyc files
            for extracted_filename in os.listdir(extracted_bytecode_path):
                if extracted_filename.lower().endswith(".pyc"):
                    extracted_file_path = os.path.join(
                        extracted_bytecode_path, extracted_filename)

                    # Decompilation using python-uncompyle6
                    res = subprocess.run(["./pycdc/pycdc", extracted_file_path],
                                         stdout=subprocess.PIPE, stderr=subprocess.PIPE)

                    # Write the decompiled content to a file
                    decompiled_content = res.stdout.decode("utf-8")
                    decompiled_filename = os.path.splitext(
                        extracted_filename)[0] + ".py"
                    decompiled_file_path = os.path.join(
                        files_directory, decompiled_filename)
                    with open(decompiled_file_path, "w") as f:
                        f.write(decompiled_content)

    # Create a new log file with a timestamp
    current_time = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    logs_file_path = os.path.join(logs_directory, f"logs_{current_time}.json")
    with open(logs_file_path, "w") as f:
        json.dump({"logs": logs}, f, default=convert_to_serializable)
    with open(logs_file_path, "r") as f:
        return f.read()
